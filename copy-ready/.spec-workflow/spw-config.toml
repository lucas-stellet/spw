# ===============================================================
# SPW Configuration
# ===============================================================
# This file centralizes behavior for the hybrid workflow
# (spec-workflow + SPW commands + subagent execution).
#
# How to use:
# 1) Copy this file into your real project at:
#    .spec-workflow/spw-config.toml
# 2) Register the SessionStart hook to run the sync script.
# 3) On every Claude session start, the active tasks template
#    will be automatically aligned with this configuration.
#
# Important note:
# - This file does NOT replace requirements/design/tasks artifacts.
# - It controls runtime behavior for commands and hooks, including
#   model routing policy for subagents.
# ===============================================================

[models]
# Model routing policy used by SPW commands.
#
# web_research:
# - Use for lightweight web search/lookup/scouting only.
# - Recommended default: "haiku"
web_research = "haiku"

# complex_reasoning:
# - Use for architecture synthesis, validation gates, and high-risk decisions.
# - Recommended default: "opus"
complex_reasoning = "opus"

# implementation:
# - Use for code-oriented implementation and standard drafting/writing tasks.
# - Recommended default: "sonnet"
implementation = "sonnet"

[execution]
# tdd_default defines the default TDD behavior for the project.
#
# false:
# - TDD is off by default (opt-in model).
# - TDD is used only when a task explicitly sets `TDD: required`
#   or when you change this config to true.
#
# true:
# - TDD is on by default.
# - Tasks using `TDD: inherit` will require a RED->GREEN cycle.
#
# Recommended starting value for your setup: false.
tdd_default = false

# If true, the executor requires minimum RED->GREEN evidence
# for tasks with active TDD (for example: test fails first, then passes).
# This avoids "tests written after the fact" without discipline.
tdd_require_red_green_evidence = true

# If true, the executor blocks batch/wave progression when it finds:
# - missing requirements traceability
# - missing per-task verification
# - critical checkpoint failures
strict_gates = true

# If true, `spw:exec` must pause after each wave/checkpoint PASS and ask the user
# whether to continue to the next wave. No automatic wave progression is allowed.
#
# true  -> explicit user authorization required between waves
# false -> command may auto-continue based on workflow policy
#
# Recommended default: true (human-in-the-loop control).
require_user_approval_between_waves = true

# If true, each completed implementation task must produce an atomic git commit
# before moving to another task/wave.
commit_per_task = true

# If true and commit_per_task=true, SPW attempts to stage/commit automatically.
# If false, SPW stops with explicit git commands for the user.
auto_commit_on_task_completion = true

# If true, checkpoint/wave PASS requires a clean git worktree.
# This prevents finishing a wave with uncommitted implementation changes.
require_clean_worktree_for_wave_pass = true

# If true, tasks that require human/manual external actions are never auto-marked
# as in-progress by the orchestrator. SPW stops and hands off to the user instead.
manual_tasks_require_human_handoff = true

[planning]
# Controls how `spw:tasks-plan` creates executable waves when `--mode` is omitted.
#
# Supported values:
# - "rolling-wave" (default): create a single executable wave per planning cycle.
#   Typical loop: plan tasks -> execute -> checkpoint -> plan next wave.
# - "all-at-once": generate all executable waves in one planning pass.
tasks_generation_strategy = "rolling-wave"

# Default wave size limit used by planning commands when `--max-wave-size` is omitted.
# CLI argument `--max-wave-size` always overrides this value.
max_wave_size = 3

[subagents]
# Max number of parallel subagents for web scouting tasks.
# Keep this moderate to avoid noisy/duplicated findings.
max_parallel_web_scouts = 3

# If true, complex/critical tasks in `spw:exec` route spec-compliance review
# to complex_reasoning model. If false, always use implementation model.
use_opus_for_complex_task_review = true

[agent_teams]
# Experimental Claude Code Agent Teams integration.
#
# enabled:
# - false (default) keeps SPW on subagent-first orchestration only.
# - true enables team creation in selected phases when supported by the client.
enabled = false

# teammate_mode:
# - "in-process" (default) works in all terminals.
# - "tmux" requires tmux/iTerm2 split panes.
# Adjust manually if you want tmux layouts.
teammate_mode = "in-process"

# If true, `spw:exec` must run with delegate mode when teams are enabled,
# so the lead agent only orchestrates and never edits code directly.
require_delegate_mode = true

# Upper bound for number of teammates created per team.
max_teammates = 4

# Phases allowed to use teams when enabled.
use_for_phases = ["design-research", "tasks-check", "checkpoint", "exec"]

[skills]
# Enables skill-aware behavior in SPW commands.
#
# true  -> commands try to load skills listed below before key phases
# false -> commands skip skill loading behavior
enabled = true

# Skill load strategy:
#
# - "subagent-first" (recommended):
#   main orchestrator does only availability preflight and delegates actual
#   skill loading/use to subagents. This keeps main-context smaller.
# - "principal-first" (legacy):
#   main orchestrator loads required skills before dispatching subagents.
#
# If missing, commands should default to "subagent-first".
load_mode = "subagent-first"

# Legacy global enforcement mode (kept for backward compatibility):
#
# - "advisory": missing required skills warn and continue
# - "strict":   missing required skills block
#
# New behavior should prefer per-stage booleans:
# - [skills.design].enforce_required
# - [skills.implementation].enforce_required
#
# Mapping fallback when per-stage key is absent:
# - enforcement="strict"   -> enforce_required=true
# - enforcement="advisory" -> enforce_required=false
enforcement = "strict"

# If true, `spw` will try to copy default skills into
# `.claude/skills/` from local/global skill directories when available.
# Missing skills do not fail installation.
auto_install_defaults_on_spw_install = true

[skills.design]
# Skills used by design/planning phases
# (`spw:design-research`, `spw:design-draft`, `spw:tasks-plan`, `spw:tasks-check`).
#
# If true, every required skill must be explicitly loaded/invoked before the
# stage continues. If any required skill is missing, the stage is BLOCKED.
#
# If false, missing required skills produce warnings and execution continues.
enforce_required = true

#
# Core Elixir defaults:
# - using-elixir-skills: routes to relevant Elixir-thinking skills
# - elixir-thinking: idiomatic architecture/refactoring guidance
# - elixir-anti-patterns: smell detection and safer alternatives
# - phoenix-thinking: LiveView/controller/socket guidance
# - ecto-thinking: schema/query/context/migration guidance
# - otp-thinking: process/state/supervision guidance
# - oban-thinking: queue/background-job guidance
required = [
  "using-elixir-skills",
  "elixir-thinking",
  "elixir-anti-patterns",
  "phoenix-thinking",
  "ecto-thinking",
  "otp-thinking",
  "oban-thinking"
]

# Optional skills: if present, SPW can use them to increase rigor.
optional = [
  "requesting-code-review"
]

[skills.implementation]
# Skills used by execution phases (`spw:exec`, `spw:checkpoint`).
#
# If true, every required skill must be explicitly loaded/invoked before the
# stage continues. If any required skill is missing, the stage is BLOCKED.
#
# If false, missing required skills produce warnings and execution continues.
enforce_required = true

required = [
  "using-elixir-skills",
  "elixir-thinking",
  "elixir-anti-patterns",
  "conventional-commits"
]

# Optional implementation skills:
# - test-driven-development: strict RED/GREEN/REFACTOR flow
# - requesting-code-review: structured review/checklist before completion
optional = [
  "test-driven-development",
  "requesting-code-review"
]

[reviews]
# Requirements revision protocol controls (used by `spw:prd` when approval is
# returned as changes-requested/rejected).

# If true, requirements revisions must be subagent-driven (no direct one-pass
# inline edits in main context).
requirements_revision_requires_subagents = true

# If true, revision flow must include a codebase impact scan before applying
# requirement edits.
requirements_revision_require_codebase_scan = true

# Minimum number of targeted clarification questions when feedback is ambiguous
# or conflicts with existing requirements/design context.
requirements_revision_min_clarifying_questions = 1

[templates]
# Controls whether the hook syncs tasks-template on SessionStart.
#
# true  -> hook active: choose variant and update tasks-template.md
# false -> hook inactive: do not auto-change the template
sync_tasks_template_on_session_start = true

# Defines how to choose tasks template variant.
#
# Supported values:
# - "auto": decide from [execution].tdd_default
# - "on":   force TDD ON variant
# - "off":  force TDD OFF variant
#
# "auto" is recommended to keep a single source of truth
# in execution.tdd_default.
tasks_template_mode = "auto"

# Path to the directory containing template variants.
# This path is relative to the project root.
# Expected example:
# .spec-workflow/user-templates/variants/
variants_dir = ".spec-workflow/user-templates/variants"

# Path to the active template used by spec-workflow.
# The hook writes here after selecting a variant.
active_tasks_template_path = ".spec-workflow/user-templates/tasks-template.md"

# Variant file name when TDD is ON.
tasks_template_tdd_on_file = "tasks-template.tdd-on.md"

# Variant file name when TDD is OFF.
tasks_template_tdd_off_file = "tasks-template.tdd-off.md"

[statusline]
# Controls SPW statusline spec detection and caching.
#
# cache_ttl_seconds:
# - Keeps statusline fast by caching the detected spec.
# - Lower values refresh more often but increase git calls.
# - Default used by the hook: 10 seconds.
cache_ttl_seconds = 10
#
# base_branches:
# - Used to discover the base branch for git diff spec detection.
# - If the current branch has an upstream (e.g. origin/main), that is used first.
# - Otherwise, these are checked in order.
base_branches = ["main", "master", "staging", "develop"]

# sticky_spec:
# - If true, statusline uses the cached spec until a new SPW command runs
#   with a different <spec-name> (cache is refreshed by the prompt hook).
# - Avoids frequent git calls and keeps spec stable during a workflow.
# - If false, cache respects cache_ttl_seconds and falls back to git/mtime.
sticky_spec = true

[safety]
# If true, the hook creates a backup of active template before overwrite.
# Format: tasks-template.md.bak-YYYYMMDDHHMMSS
backup_before_overwrite = true

# If true, the hook cleans up existing backup files after synchronization
# (or when already synchronized). This is useful to avoid backup accumulation.
cleanup_backups_after_sync = false

# Number of backup files to keep when cleanup is enabled.
#
# Examples:
# - 0 -> delete all backups (including the one created in the current sync)
# - 1 -> keep only the most recent backup
# - 5 -> keep the 5 most recent backups
backup_retention_count = 5

# If true, the hook runs in dry-run mode (does not write files).
# Useful for validating behavior without changing anything.
dry_run = false

# If true, hook exits with code 1 when variant/config is missing.
# If false, it logs a warning and exits without breaking the session.
fail_hard_on_missing_template = false

[hooks]
# Enables SPW runtime guard hooks (PreToolUse/UserPromptSubmit/Stop).
#
# true  -> hook scripts run and enforce/warn according to `enforcement_mode`
# false -> hook scripts exit immediately (no-op)
enabled = true

# Hook enforcement mode:
#
# - "warn": emit warnings but do not block execution
# - "block": deny violating actions (hook exits with blocking status)
#
# Recommended rollout:
# 1) start with "warn"
# 2) move to "block" after team validation
enforcement_mode = "warn"

# If true, hooks print explicit diagnostics when a rule is triggered.
# If false, hooks stay quieter (still enforce).
verbose = true

# Window (in minutes) used by Stop hook to evaluate "recent" run folders for
# file-first handoff completeness. Older runs are ignored by the guard.
recent_run_window_minutes = 30

# Per-guard toggles
guard_prompt_require_spec = true
guard_paths = true
guard_wave_layout = true
guard_stop_handoff = true
