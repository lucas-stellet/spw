# ===============================================================
# SPW Configuration
# ===============================================================
# This file centralizes behavior for the hybrid workflow
# (spec-workflow + SPW commands + subagent execution).
#
# How to use:
# 1) Copy this file into your real project at:
#    .spec-workflow/spw-config.toml
# 2) Register the SessionStart hook to run the sync script.
# 3) On every Claude session start, the active tasks template
#    will be automatically aligned with this configuration.
#
# Important note:
# - This file does NOT replace requirements/design/tasks artifacts.
# - It controls runtime behavior for commands and hooks, including
#   model routing policy for subagents.
# ===============================================================

[models]
# Model routing policy used by SPW commands.
#
# web_research:
# - Use for lightweight web search/lookup/scouting only.
# - Recommended default: "haiku"
web_research = "haiku"

# complex_reasoning:
# - Use for architecture synthesis, validation gates, and high-risk decisions.
# - Recommended default: "opus"
complex_reasoning = "opus"

# implementation:
# - Use for code-oriented implementation and standard drafting/writing tasks.
# - Recommended default: "sonnet"
implementation = "sonnet"

[execution]
# tdd_default defines the default TDD behavior for the project.
#
# false:
# - TDD is off by default (opt-in model).
# - TDD is used only when a task explicitly sets `TDD: required`
#   or when you change this config to true.
#
# true:
# - TDD is on by default.
# - Tasks using `TDD: inherit` will require a RED->GREEN cycle.
#
# Recommended starting value for your setup: false.
tdd_default = false

# If true, the executor requires minimum RED->GREEN evidence
# for tasks with active TDD (for example: test fails first, then passes).
# This avoids "tests written after the fact" without discipline.
tdd_require_red_green_evidence = true

# If true, the executor blocks batch/wave progression when it finds:
# - missing requirements traceability
# - missing per-task verification
# - critical checkpoint failures
strict_gates = true

# If true, `spw:exec` must pause after each wave/checkpoint PASS and ask the user
# whether to continue to the next wave. No automatic wave progression is allowed.
#
# true  -> explicit user authorization required between waves
# false -> command may auto-continue based on workflow policy
#
# Recommended default: true (human-in-the-loop control).
require_user_approval_between_waves = true

# If true, each completed implementation task must produce an atomic git commit
# before moving to another task/wave.
commit_per_task = true

# If true and commit_per_task=true, SPW attempts to stage/commit automatically.
# If false, SPW stops with explicit git commands for the user.
auto_commit_on_task_completion = true

# If true, checkpoint/wave PASS requires a clean git worktree.
# This prevents finishing a wave with uncommitted implementation changes.
require_clean_worktree_for_wave_pass = true

# If true, tasks that require human/manual external actions are never auto-marked
# as in-progress by the orchestrator. SPW stops and hands off to the user instead.
manual_tasks_require_human_handoff = true

[subagents]
# Max number of parallel subagents for web scouting tasks.
# Keep this moderate to avoid noisy/duplicated findings.
max_parallel_web_scouts = 3

# If true, complex/critical tasks in `spw:exec` route spec-compliance review
# to complex_reasoning model. If false, always use implementation model.
use_opus_for_complex_task_review = true

[skills]
# Enables skill-aware behavior in SPW commands.
#
# true  -> commands try to load skills listed below before key phases
# false -> commands skip skill loading behavior
enabled = true

# Legacy global enforcement mode (kept for backward compatibility):
#
# - "advisory": missing required skills warn and continue
# - "strict":   missing required skills block
#
# New behavior should prefer per-stage booleans:
# - [skills.design].enforce_required
# - [skills.implementation].enforce_required
#
# Mapping fallback when per-stage key is absent:
# - enforcement="strict"   -> enforce_required=true
# - enforcement="advisory" -> enforce_required=false
enforcement = "strict"

# If true, `spw-install` will try to copy default skills into
# `.claude/skills/` from local/global skill directories when available.
# Missing skills do not fail installation.
auto_install_defaults_on_spw_install = true

[skills.design]
# Skills used by design/planning phases
# (`spw:design-research`, `spw:design-draft`, `spw:tasks-plan`, `spw:tasks-check`).
#
# If true, every required skill must be explicitly loaded/invoked before the
# stage continues. If any required skill is missing, the stage is BLOCKED.
#
# If false, missing required skills produce warnings and execution continues.
enforce_required = true

#
# Core Elixir defaults:
# - using-elixir-skills: routes to relevant Elixir-thinking skills
# - elixir-thinking: idiomatic architecture/refactoring guidance
# - elixir-anti-patterns: smell detection and safer alternatives
# - phoenix-thinking: LiveView/controller/socket guidance
# - ecto-thinking: schema/query/context/migration guidance
# - otp-thinking: process/state/supervision guidance
# - oban-thinking: queue/background-job guidance
required = [
  "using-elixir-skills",
  "elixir-thinking",
  "elixir-anti-patterns",
  "phoenix-thinking",
  "ecto-thinking",
  "otp-thinking",
  "oban-thinking"
]

# Optional skills: if present, SPW can use them to increase rigor.
optional = [
  "requesting-code-review"
]

[skills.implementation]
# Skills used by execution phases (`spw:exec`, `spw:checkpoint`).
#
# If true, every required skill must be explicitly loaded/invoked before the
# stage continues. If any required skill is missing, the stage is BLOCKED.
#
# If false, missing required skills produce warnings and execution continues.
enforce_required = true

required = [
  "using-elixir-skills",
  "elixir-thinking",
  "elixir-anti-patterns",
  "conventional-commits"
]

# Optional implementation skills:
# - test-driven-development: strict RED/GREEN/REFACTOR flow
# - requesting-code-review: structured review/checklist before completion
optional = [
  "test-driven-development",
  "requesting-code-review"
]

[reviews]
# Requirements revision protocol controls (used by `spw:prd` when approval is
# returned as changes-requested/rejected).

# If true, requirements revisions must be subagent-driven (no direct one-pass
# inline edits in main context).
requirements_revision_requires_subagents = true

# If true, revision flow must include a codebase impact scan before applying
# requirement edits.
requirements_revision_require_codebase_scan = true

# Minimum number of targeted clarification questions when feedback is ambiguous
# or conflicts with existing requirements/design context.
requirements_revision_min_clarifying_questions = 1

[templates]
# Controls whether the hook syncs tasks-template on SessionStart.
#
# true  -> hook active: choose variant and update tasks-template.md
# false -> hook inactive: do not auto-change the template
sync_tasks_template_on_session_start = true

# Defines how to choose tasks template variant.
#
# Supported values:
# - "auto": decide from [execution].tdd_default
# - "on":   force TDD ON variant
# - "off":  force TDD OFF variant
#
# "auto" is recommended to keep a single source of truth
# in execution.tdd_default.
tasks_template_mode = "auto"

# Path to the directory containing template variants.
# This path is relative to the project root.
# Expected example:
# .spec-workflow/user-templates/variants/
variants_dir = ".spec-workflow/user-templates/variants"

# Path to the active template used by spec-workflow.
# The hook writes here after selecting a variant.
active_tasks_template_path = ".spec-workflow/user-templates/tasks-template.md"

# Variant file name when TDD is ON.
tasks_template_tdd_on_file = "tasks-template.tdd-on.md"

# Variant file name when TDD is OFF.
tasks_template_tdd_off_file = "tasks-template.tdd-off.md"

[safety]
# If true, the hook creates a backup of active template before overwrite.
# Format: tasks-template.md.bak-YYYYMMDDHHMMSS
backup_before_overwrite = true

# If true, the hook cleans up existing backup files after synchronization
# (or when already synchronized). This is useful to avoid backup accumulation.
cleanup_backups_after_sync = false

# Number of backup files to keep when cleanup is enabled.
#
# Examples:
# - 0 -> delete all backups (including the one created in the current sync)
# - 1 -> keep only the most recent backup
# - 5 -> keep the 5 most recent backups
backup_retention_count = 5

# If true, the hook runs in dry-run mode (does not write files).
# Useful for validating behavior without changing anything.
dry_run = false

# If true, hook exits with code 1 when variant/config is missing.
# If false, it logs a warning and exits without breaking the session.
fail_hard_on_missing_template = false
