#!/usr/bin/env bash
set -euo pipefail

SPW_REPO="${SPW_REPO:-lucas-stellet/spw}"
SPW_REF="${SPW_REF:-main}"
SPW_HOME="${SPW_HOME:-${XDG_DATA_HOME:-$HOME/.local/share}/spw}"
SPW_AUTO_UPDATE="${SPW_AUTO_UPDATE:-false}"

repo_key="${SPW_REPO//\//__}"
repo_dir="${SPW_HOME}/repos/${repo_key}"
state_dir="${SPW_HOME}/state"
last_updated_file="${state_dir}/${repo_key}.last_updated"

show_help() {
  cat <<'USAGE'
spw - install or inspect the SPW kit in the current project

Usage:
  spw
  spw install
  spw skills
  spw status
  spw update
  spw doctor

Environment:
  SPW_REPO         GitHub repository (default: lucas-stellet/spw)
  SPW_REF          Branch/tag/sha to use (default: main)
  SPW_HOME         Cache root (default: ~/.local/share/spw)
  SPW_KIT_DIR      Explicit kit directory override
  SPW_AUTO_UPDATE  true|false (default: false)

Default behavior:
  - `spw` shows this help output
  - use `spw install` to install the kit in the current project
USAGE
}

require_cmd() {
  local cmd="$1"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    echo "[spw] Required command not found: $cmd" >&2
    exit 1
  fi
}

base64_decode() {
  if printf 'dGVzdA==' | base64 --decode >/dev/null 2>&1; then
    base64 --decode
    return 0
  fi

  if printf 'dGVzdA==' | base64 -D >/dev/null 2>&1; then
    base64 -D
    return 0
  fi

  echo "[spw] Could not decode base64 with this system 'base64' command." >&2
  return 1
}

download_remote_wrapper() {
  local target_file="$1"
  require_cmd gh

  gh api "repos/${SPW_REPO}/contents/bin/spw?ref=${SPW_REF}" --jq '.content' \
    | tr -d '\n' \
    | base64_decode >"$target_file"
  chmod +x "$target_file"
}

resolve_self_bin_path() {
  local source_path="${BASH_SOURCE[0]}"
  local source_dir
  local link_target

  if [[ "$source_path" != /* ]]; then
    source_dir="$(cd "$(dirname "$source_path")" && pwd -P)"
    source_path="${source_dir}/$(basename "$source_path")"
  fi

  if [ -L "$source_path" ]; then
    link_target="$(readlink "$source_path")"
    if [[ "$link_target" = /* ]]; then
      source_path="$link_target"
    else
      source_dir="$(cd "$(dirname "$source_path")" && pwd -P)"
      source_path="${source_dir}/${link_target}"
    fi
  fi

  printf '%s' "$source_path"
}

self_update_wrapper_and_reexec() {
  local self_bin
  local tmp_bin

  if [ "${SPW_SELF_UPDATED:-false}" = "true" ]; then
    return 0
  fi

  self_bin="$(resolve_self_bin_path)"
  if [ -z "$self_bin" ]; then
    echo "[spw] Could not resolve current wrapper path; continuing cache update only." >&2
    return 0
  fi

  tmp_bin="$(mktemp "${TMPDIR:-/tmp}/spw-wrapper.XXXXXX")"
  download_remote_wrapper "$tmp_bin"

  if cmp -s "$tmp_bin" "$self_bin"; then
    rm -f "$tmp_bin"
    echo "[spw] Wrapper already up to date: $self_bin" >&2
    return 0
  fi

  cp "$tmp_bin" "$self_bin"
  chmod +x "$self_bin"
  rm -f "$tmp_bin"
  echo "[spw] Updated wrapper: $self_bin (${SPW_REPO}@${SPW_REF})" >&2
  echo "[spw] Re-running update with the new wrapper" >&2

  exec env SPW_SELF_UPDATED=true "$self_bin" update
}

record_last_updated() {
  mkdir -p "$state_dir"
  date -u +"%Y-%m-%dT%H:%M:%SZ" >"$last_updated_file"
}

read_last_updated() {
  if [ -f "$last_updated_file" ]; then
    tr -d '\n' <"$last_updated_file"
    return 0
  fi

  printf "never (run 'spw update')"
}

repo_commit() {
  if [ ! -d "$repo_dir/.git" ] || ! command -v git >/dev/null 2>&1; then
    return 1
  fi

  git -C "$repo_dir" rev-parse --short=12 HEAD 2>/dev/null
}

repo_commit_date() {
  if [ ! -d "$repo_dir/.git" ] || ! command -v git >/dev/null 2>&1; then
    return 1
  fi

  git -C "$repo_dir" show -s --format=%cI HEAD 2>/dev/null
}

version_line() {
  local commit
  if commit="$(repo_commit)"; then
    printf '%s@%s' "$SPW_REF" "$commit"
    return 0
  fi

  printf "unavailable (run 'spw update')"
}

commit_date_line() {
  local commit_date
  if commit_date="$(repo_commit_date)"; then
    printf '%s' "$commit_date"
    return 0
  fi

  printf 'unknown'
}

purge_cache_for_update() {
  local cache_root="${SPW_HOME%/}"

  if [ -z "$cache_root" ] || [ "$cache_root" = "/" ]; then
    echo "[spw] Refusing to purge unsafe cache path: '$SPW_HOME'" >&2
    exit 1
  fi

  if [ "$cache_root" = "$HOME" ]; then
    echo "[spw] Refusing to purge home directory as cache path: '$SPW_HOME'" >&2
    exit 1
  fi

  if [ -d "$cache_root" ]; then
    echo "[spw] Clearing cache directory: $cache_root" >&2
    rm -rf "$cache_root"
  fi
}

ensure_repo() {
  require_cmd gh
  require_cmd git
  mkdir -p "$(dirname "$repo_dir")"
  if [ ! -d "$repo_dir/.git" ]; then
    echo "[spw] Cloning ${SPW_REPO} into ${repo_dir}" >&2
    gh repo clone "$SPW_REPO" "$repo_dir" -- --quiet
    record_last_updated
  fi
}

checkout_ref() {
  if git -C "$repo_dir" rev-parse --verify --quiet "origin/$SPW_REF" >/dev/null; then
    git -C "$repo_dir" checkout -B "$SPW_REF" "origin/$SPW_REF" >/dev/null 2>&1
  else
    git -C "$repo_dir" checkout "$SPW_REF" >/dev/null 2>&1
  fi
}

update_repo() {
  ensure_repo
  echo "[spw] Updating ${SPW_REPO} (${SPW_REF})" >&2
  git -C "$repo_dir" fetch --prune origin >/dev/null 2>&1
  checkout_ref
  record_last_updated
  echo "[spw] version: $(version_line)" >&2
  echo "[spw] commit date: $(commit_date_line)" >&2
  echo "[spw] last updated: $(read_last_updated)" >&2
}

resolve_kit_dir() {
  if [ -n "${SPW_KIT_DIR:-}" ]; then
    printf '%s' "$SPW_KIT_DIR"
    return 0
  fi

  ensure_repo
  if [ "$SPW_AUTO_UPDATE" = "true" ]; then
    update_repo
  else
    checkout_ref
  fi
  printf '%s' "$repo_dir/copy-ready"
}

doctor() {
  local kit_dir
  if [ -n "${SPW_KIT_DIR:-}" ]; then
    kit_dir="$SPW_KIT_DIR"
  else
    kit_dir="$repo_dir/copy-ready"
  fi

  echo "spw doctor"
  echo "repo: $SPW_REPO"
  echo "ref: $SPW_REF"
  echo "version: $(version_line)"
  echo "commit date: $(commit_date_line)"
  echo "last updated: $(read_last_updated)"
  echo "home: $SPW_HOME"
  echo "cache repo dir: $repo_dir"
  echo "kit dir: $kit_dir"
  echo "gh: $(command -v gh || echo missing)"
  echo "git: $(command -v git || echo missing)"
}

cmd="${1:-help}"

case "$cmd" in
  -h|--help|help)
    show_help
    exit 0
    ;;
  update)
    if [ -n "${SPW_KIT_DIR:-}" ]; then
      echo "[spw] SPW_KIT_DIR is set; skipping remote update." >&2
      exit 0
    fi
    self_update_wrapper_and_reexec
    purge_cache_for_update
    update_repo
    exit 0
    ;;
  doctor)
    doctor
    exit 0
    ;;
esac

kit_dir="$(resolve_kit_dir)"
if [ ! -x "$kit_dir/install.sh" ]; then
  echo "[spw] install.sh not found or not executable at: $kit_dir/install.sh" >&2
  exit 1
fi

exec bash "$kit_dir/install.sh" "$@"
