#!/usr/bin/env bash
set -euo pipefail

ORACULO_REPO="${ORACULO_REPO:-lucas-stellet/oraculo}"
ORACULO_REF="${ORACULO_REF:-main}"
ORACULO_HOME="${ORACULO_HOME:-${XDG_DATA_HOME:-$HOME/.local/share}/oraculo}"
ORACULO_AUTO_UPDATE="${ORACULO_AUTO_UPDATE:-false}"

repo_key="${ORACULO_REPO//\//__}"
repo_dir="${ORACULO_HOME}/repos/${repo_key}"
state_dir="${ORACULO_HOME}/state"
last_updated_file="${state_dir}/${repo_key}.last_updated"

show_help() {
  cat <<'USAGE'
oraculo - install or inspect the Oraculo kit in the current project

Usage:
  oraculo
  oraculo install [--global]
  oraculo init
  oraculo skills
  oraculo skills install
  oraculo status
  oraculo update
  oraculo doctor

Installation modes:
  install           Full local install (commands, workflows, hooks, config, templates)
  install --global  Global install to ~/.claude/ (commands, workflows, hooks, skills)
  init              Project init only (config, templates, snippets, .gitattributes)

Environment:
  ORACULO_REPO         GitHub repository (default: lucas-stellet/oraculo)
  ORACULO_REF          Branch/tag/sha to use (default: main)
  ORACULO_HOME         Cache root (default: ~/.local/share/oraculo)
  ORACULO_KIT_DIR      Explicit kit directory override
  ORACULO_AUTO_UPDATE  true|false (default: false)

Default behavior:
  - `oraculo` shows this help output
  - use `oraculo install` to install the kit in the current project
  - use `oraculo install --global` + `oraculo init` for two-tier setup
USAGE
}

require_cmd() {
  local cmd="$1"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    echo "[oraculo] Required command not found: $cmd" >&2
    exit 1
  fi
}

base64_decode() {
  if printf 'dGVzdA==' | base64 --decode >/dev/null 2>&1; then
    base64 --decode
    return 0
  fi

  if printf 'dGVzdA==' | base64 -D >/dev/null 2>&1; then
    base64 -D
    return 0
  fi

  echo "[oraculo] Could not decode base64 with this system 'base64' command." >&2
  return 1
}

download_remote_wrapper() {
  local target_file="$1"
  require_cmd gh

  gh api "repos/${ORACULO_REPO}/contents/bin/oraculo?ref=${ORACULO_REF}" --jq '.content' \
    | tr -d '\n' \
    | base64_decode >"$target_file"
  chmod +x "$target_file"
}

resolve_self_bin_path() {
  local source_path="${BASH_SOURCE[0]}"
  local source_dir
  local link_target

  if [[ "$source_path" != /* ]]; then
    source_dir="$(cd "$(dirname "$source_path")" && pwd -P)"
    source_path="${source_dir}/$(basename "$source_path")"
  fi

  if [ -L "$source_path" ]; then
    link_target="$(readlink "$source_path")"
    if [[ "$link_target" = /* ]]; then
      source_path="$link_target"
    else
      source_dir="$(cd "$(dirname "$source_path")" && pwd -P)"
      source_path="${source_dir}/${link_target}"
    fi
  fi

  printf '%s' "$source_path"
}

self_update_wrapper_and_reexec() {
  local self_bin
  local tmp_bin

  if [ "${ORACULO_SELF_UPDATED:-false}" = "true" ]; then
    return 0
  fi

  self_bin="$(resolve_self_bin_path)"
  if [ -z "$self_bin" ]; then
    echo "[oraculo] Could not resolve current wrapper path; continuing cache update only." >&2
    return 0
  fi

  tmp_bin="$(mktemp "${TMPDIR:-/tmp}/oraculo-wrapper.XXXXXX")"
  download_remote_wrapper "$tmp_bin"

  if cmp -s "$tmp_bin" "$self_bin"; then
    rm -f "$tmp_bin"
    echo "[oraculo] Wrapper already up to date: $self_bin" >&2
    return 0
  fi

  cp "$tmp_bin" "$self_bin"
  chmod +x "$self_bin"
  rm -f "$tmp_bin"
  echo "[oraculo] Updated wrapper: $self_bin (${ORACULO_REPO}@${ORACULO_REF})" >&2
  echo "[oraculo] Re-running update with the new wrapper" >&2

  exec env ORACULO_SELF_UPDATED=true "$self_bin" update
}

record_last_updated() {
  mkdir -p "$state_dir"
  date -u +"%Y-%m-%dT%H:%M:%SZ" >"$last_updated_file"
}

read_last_updated() {
  if [ -f "$last_updated_file" ]; then
    tr -d '\n' <"$last_updated_file"
    return 0
  fi

  printf "never (run 'oraculo update')"
}

repo_commit() {
  if [ ! -d "$repo_dir/.git" ] || ! command -v git >/dev/null 2>&1; then
    return 1
  fi

  git -C "$repo_dir" rev-parse --short=12 HEAD 2>/dev/null
}

repo_commit_date() {
  if [ ! -d "$repo_dir/.git" ] || ! command -v git >/dev/null 2>&1; then
    return 1
  fi

  git -C "$repo_dir" show -s --format=%cI HEAD 2>/dev/null
}

version_line() {
  local commit
  if commit="$(repo_commit)"; then
    printf '%s@%s' "$ORACULO_REF" "$commit"
    return 0
  fi

  printf "unavailable (run 'oraculo update')"
}

commit_date_line() {
  local commit_date
  if commit_date="$(repo_commit_date)"; then
    printf '%s' "$commit_date"
    return 0
  fi

  printf 'unknown'
}

purge_cache_for_update() {
  local cache_root="${ORACULO_HOME%/}"

  if [ -z "$cache_root" ] || [ "$cache_root" = "/" ]; then
    echo "[oraculo] Refusing to purge unsafe cache path: '$ORACULO_HOME'" >&2
    exit 1
  fi

  if [ "$cache_root" = "$HOME" ]; then
    echo "[oraculo] Refusing to purge home directory as cache path: '$ORACULO_HOME'" >&2
    exit 1
  fi

  if [ -d "$cache_root" ]; then
    echo "[oraculo] Clearing cache directory: $cache_root" >&2
    rm -rf "$cache_root"
  fi
}

ensure_repo() {
  require_cmd gh
  require_cmd git
  mkdir -p "$(dirname "$repo_dir")"
  if [ ! -d "$repo_dir/.git" ]; then
    echo "[oraculo] Cloning ${ORACULO_REPO} into ${repo_dir}" >&2
    gh repo clone "$ORACULO_REPO" "$repo_dir" -- --quiet
    record_last_updated
  fi
}

checkout_ref() {
  if git -C "$repo_dir" rev-parse --verify --quiet "origin/$ORACULO_REF" >/dev/null; then
    git -C "$repo_dir" checkout -B "$ORACULO_REF" "origin/$ORACULO_REF" >/dev/null 2>&1
  else
    git -C "$repo_dir" checkout "$ORACULO_REF" >/dev/null 2>&1
  fi
}

update_repo() {
  ensure_repo
  echo "[oraculo] Updating ${ORACULO_REPO} (${ORACULO_REF})" >&2
  git -C "$repo_dir" fetch --prune origin >/dev/null 2>&1
  checkout_ref
  record_last_updated
  echo "[oraculo] version: $(version_line)" >&2
  echo "[oraculo] commit date: $(commit_date_line)" >&2
  echo "[oraculo] last updated: $(read_last_updated)" >&2
}

resolve_kit_dir() {
  if [ -n "${ORACULO_KIT_DIR:-}" ]; then
    printf '%s' "$ORACULO_KIT_DIR"
    return 0
  fi

  ensure_repo
  if [ "$ORACULO_AUTO_UPDATE" = "true" ]; then
    update_repo
  else
    checkout_ref
  fi
  printf '%s' "$repo_dir/copy-ready"
}

doctor() {
  local kit_dir
  if [ -n "${ORACULO_KIT_DIR:-}" ]; then
    kit_dir="$ORACULO_KIT_DIR"
  else
    kit_dir="$repo_dir/copy-ready"
  fi

  echo "oraculo doctor"
  echo "repo: $ORACULO_REPO"
  echo "ref: $ORACULO_REF"
  echo "version: $(version_line)"
  echo "commit date: $(commit_date_line)"
  echo "last updated: $(read_last_updated)"
  echo "home: $ORACULO_HOME"
  echo "cache repo dir: $repo_dir"
  echo "kit dir: $kit_dir"
  echo "gh: $(command -v gh || echo missing)"
  echo "git: $(command -v git || echo missing)"
}

cmd="${1:-help}"

case "$cmd" in
  -h|--help|help)
    show_help
    exit 0
    ;;
  update)
    if [ -n "${ORACULO_KIT_DIR:-}" ]; then
      echo "[oraculo] ORACULO_KIT_DIR is set; skipping remote update." >&2
      exit 0
    fi
    self_update_wrapper_and_reexec
    purge_cache_for_update
    update_repo
    exit 0
    ;;
  doctor)
    doctor
    exit 0
    ;;
esac

kit_dir="$(resolve_kit_dir)"
if [ ! -x "$kit_dir/install.sh" ]; then
  echo "[oraculo] install.sh not found or not executable at: $kit_dir/install.sh" >&2
  exit 1
fi

exec bash "$kit_dir/install.sh" "$@"
