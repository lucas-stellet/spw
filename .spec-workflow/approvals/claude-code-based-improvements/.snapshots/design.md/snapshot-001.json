{
  "id": "snapshot_1771012717672_tvtpia8ym",
  "approvalId": "approval_1771012717660_67dh2vcz3",
  "approvalTitle": "Design document for claude-code-based-improvements",
  "version": 1,
  "timestamp": "2026-02-13T19:58:37.672Z",
  "trigger": "initial",
  "status": "pending",
  "content": "---\nspw:\n  schema: 1\n  spec: \"claude-code-based-improvements\"\n  doc: \"design\"\n  status: \"draft\"\n  source: \"spw:design-draft\"\n  updated_at: \"2026-02-13\"\n  inputs:\n    - \".spec-workflow/specs/claude-code-based-improvements/requirements.md\"\n    - \".spec-workflow/specs/claude-code-based-improvements/design/DESIGN-RESEARCH.md\"\n  requirements:\n    - \"REQ-001\"\n    - \"REQ-002\"\n    - \"REQ-003\"\n    - \"REQ-004\"\n    - \"REQ-005\"\n    - \"REQ-006\"\n    - \"REQ-007\"\n  decisions:\n    - \"D-001: New validate package\"\n    - \"D-002: yaml.v3 for frontmatter\"\n    - \"D-003: Graduated status.json validation\"\n    - \"D-004: Top-level validate command\"\n    - \"D-005: Content-hash mirror comparison\"\n    - \"D-006: Iteration state file\"\n  risk: \"medium\"\n  open_questions: []\n---\n\n# Design Document\n\n## Overview\n\n- **Technical objective:** Move SPW validations and guardrails from prompt markdown into deterministic Go CLI commands, creating a `spw validate` command group and extending existing dispatch tools with full contract enforcement, confidence-based audit gating, and iteration limits.\n- **Relationship to the product problem:** Critical workflow rules currently rely on prompt-based enforcement which is non-deterministic. By codifying validation in Go, SPW gains reproducible, testable, CI-compatible enforcement of frontmatter contracts, mirror integrity, status.json schemas, and audit quality thresholds.\n\n## Requirement Mapping (Required)\n\n| Requirement | Technical Decision | Components/Files | Test Strategy |\n|---|---|---|---|\n| REQ-001: Frontmatter validation | New `spw validate prompts` command. Schema-driven `[]FieldRule` validation with yaml.v3. Exit codes 0/1/2. JSON output via `--json`. | `cli/internal/validate/prompts.go`, `cli/internal/validate/schema.go`, `cli/internal/cli/validate_cmd.go` | Table-driven: valid file, missing each required field, invalid model, no frontmatter, empty file, extra fields. Golden file for JSON output. |\n| REQ-002: Mirror validation | `--strict` flag on `spw validate prompts`. Phase 1: filesystem mirror diff via SHA-256 content hash. Phase 2: embedded asset comparison. Symlink target validation. | `cli/internal/validate/mirror.go` | Matching files, divergent content, missing mirror, extra files, broken symlinks. Embedded comparison. Integration on real repo. |\n| REQ-003: status.json enforcement | Extend `DispatchReadStatus` with graduated validation. Default: 2 required + 3 optional (warn). Strict: all 5 required. | `cli/internal/validate/status.go`, `cli/internal/tools/dispatch_status.go` | All 5 present, missing optional (default=warn, strict=error), wrong types, invalid enum, null vs missing. |\n| REQ-004: High-signal audit gate | New `[audit]` config section. `AuditConfig` struct. Gate: blocked + `confidence < threshold` becomes warning. | `cli/internal/config/config.go`, `cli/internal/validate/audit.go`, `cli/internal/tools/dispatch_status.go` | Boundary: exactly at 0.8, above, below. Downgrade behavior. Missing confidence field. |\n| REQ-005: Iteration limits | `max_revision_attempts=3`, `max_replan_attempts=2` in `[execution]`. `_iteration_state.json` per run-dir. | `cli/internal/config/config.go`, `cli/internal/validate/iteration.go` | Counter increment, threshold trigger, state persistence, config override. |\n| REQ-006: Doc updates | Checklist enforcement per implementation task. | `README.md`, `AGENTS.md`, `docs/SPW-WORKFLOW.md`, `hooks/README.md`, `copy-ready/README.md` | Manual checklist per task. |\n| REQ-007: Regression tests | Table-driven Go tests per validator. Golden file tests for JSON stability. | `cli/internal/validate/*_test.go` | Minimum test matrix per validator. Integration smoke test on actual repository. |\n\n## Considered Options and Trade-offs\n\n### Option A: New `validate` package with top-level command (recommended)\n\n- **Pros:** Clean separation of concerns. Discoverable CLI namespace (`spw validate`). Room for future subcommands (`spw validate docs`, `spw validate config`). Follows shellcheck/golangci-lint conventions.\n- **Cons:** Adds a new top-level command to root. New package to maintain.\n- **When not to use:** If the validate surface area remains trivially small (it will not, given 5+ validators).\n\n### Option B: Validation logic inside existing `tools` package\n\n- **Pros:** No new package. Reuses existing wiring.\n- **Cons:** `tools` package already handles dispatch, config, and model resolution. Adding validation creates a kitchen-sink package. Less discoverable CLI path (`spw tools validate-prompts`).\n\n### Frontmatter parser: yaml.v3 vs manual parser\n\n- **yaml.v3 (chosen):** Handles YAML arrays natively for `allowed-tools: [Read, Grep, Bash]`. Type-safe struct unmarshalling. Small dependency (no transitive deps). Well-established in Go ecosystem.\n- **Manual parser:** Zero deps but cannot parse arrays. Would require `allowed-tools` to be a comma-separated string, deviating from standard YAML.\n\n### status.json validation: Graduated vs breaking\n\n- **Graduated (chosen):** Default mode preserves backward compatibility with existing 2-field status.json files. Strict mode opt-in for full enforcement. Matches requirements (\"no version bump needed\").\n- **Breaking:** Simpler code but invalidates all existing runs.\n\n## Alignment with Steering Docs\n\n### tech.md\n\n- **Applied standards:** Go CLI with Cobra. Exit code convention (0/1/2). JSON output for CI integration. `BurntSushi/toml` for config parsing. Table-driven tests.\n\n### structure.md\n\n- **Applied organization conventions:** New package at `cli/internal/validate/` following existing structure (`cli/internal/hook/`, `cli/internal/tools/`, `cli/internal/config/`). Cobra command wiring in `cli/internal/cli/validate_cmd.go` following `hook.go`, `tools.go` patterns.\n\n## Code Reuse\n\n- **Modules/files to reuse:**\n  - `cli/internal/tools/output.go` `Output()` function for JSON/plain formatting\n  - `cli/internal/config/config.go` `Config` struct, `Defaults()`, `Load()`, `GetValue()` for config extension\n  - `cli/internal/embedded/embed.go` `Workflows.ReadFile` and `AllWorkflowNames` for embedded asset validation\n  - `cli/internal/registry/registry.go` as reference for frontmatter field patterns\n  - `cli/internal/tools/dispatch_test.go` as test structure template\n  - `scripts/validate-thin-orchestrator.sh` mirror logic to port to Go\n- **Planned extensions:**\n  - `AuditConfig` struct added to `Config` in `config.go`\n  - `MaxRevisionAttempts` and `MaxReplanAttempts` fields added to `ExecutionConfig`\n  - New `newValidateCmd()` registered in `root.go`\n- **Code to avoid / critical legacy:**\n  - Do not modify `parseKeyValue` in `registry.go` (different concern, different parsing context)\n  - Do not break the existing `DispatchReadStatus` default behavior (2-field validation must remain the default)\n\n## Architecture\n\n### Boundaries\n\n- **`cli/internal/validate/`**: All static validation logic. No runtime dispatch concerns. Pure functions that take paths/content and return validation results.\n- **`cli/internal/cli/validate_cmd.go`**: Cobra command wiring only. Delegates to `validate` package.\n- **`cli/internal/config/`**: Config struct extensions for `[audit]` and iteration limits. No validation logic here.\n- **`cli/internal/tools/dispatch_status.go`**: Integration point for enhanced status.json validation and audit confidence gating. Calls into `validate` package.\n- **Allowed dependencies:**\n  - `validate` -> `config` (reads thresholds)\n  - `validate` -> `embedded` (for `--strict` asset comparison)\n  - `cli` -> `validate` (command wiring)\n  - `tools` -> `validate` (dispatch_status uses status validation)\n  - `validate` does NOT depend on `tools`, `hook`, or `cli`\n\n### Main flow\n\n```mermaid\ngraph TD\n    CLI[\"spw validate prompts\"]\n    CLI --> Parse[\"Parse flags<br/>--json, --strict\"]\n    Parse --> Scan[\"Scan commands/spw/*.md\"]\n    Scan --> FM[\"Extract YAML frontmatter<br/>yaml.v3\"]\n    FM --> Schema[\"Validate against FieldRule schema<br/>name, description, argument-hint,<br/>allowed-tools, model\"]\n    Schema --> Strict{--strict?}\n    Strict -->|No| Report[\"Generate report<br/>violations + stats\"]\n    Strict -->|Yes| Mirror[\"Mirror validation<br/>SHA-256 content hash\"]\n    Mirror --> Embed[\"Embedded asset comparison<br/>embedded.Workflows vs filesystem\"]\n    Embed --> Symlink[\"Overlay symlink validation\"]\n    Symlink --> Report\n    Report --> Output{--json?}\n    Output -->|Yes| JSON[\"JSON output<br/>ok, summary, violations, stats\"]\n    Output -->|No| Table[\"Human-readable table\"]\n    JSON --> Exit[\"Exit code: 0=pass, 1=violations, 2=error\"]\n    Table --> Exit\n```\n\n### Status.json validation flow\n\n```mermaid\ngraph TD\n    Read[\"dispatch-read-status\"]\n    Read --> ParseJSON[\"Parse status.json\"]\n    ParseJSON --> Core[\"Validate core fields<br/>status: pass|blocked<br/>summary: non-empty string\"]\n    Core --> Mode{Strict mode?}\n    Mode -->|Default| WarnExt[\"Warn if extended fields missing<br/>skills_used, skills_missing,<br/>model_override_reason\"]\n    Mode -->|Strict| ReqExt[\"Require all 5 fields<br/>Type validation per field\"]\n    WarnExt --> AuditCheck{Audit context?}\n    ReqExt --> AuditCheck\n    AuditCheck -->|Yes| Confidence[\"Check confidence >= audit_min_confidence<br/>Check validated == true\"]\n    AuditCheck -->|No| Result[\"Return StatusValidationResult\"]\n    Confidence --> Gate{Meets threshold?}\n    Gate -->|Yes| Block[\"Keep as BLOCKED\"]\n    Gate -->|No| Downgrade[\"Downgrade to WARNING<br/>Log in _handoff.md\"]\n    Block --> Result\n    Downgrade --> Result\n```\n\n### Iteration limit flow\n\n```mermaid\ngraph TD\n    Start[\"Revision/replan cycle starts\"]\n    Start --> ReadState[\"Read _iteration_state.json<br/>from run-dir\"]\n    ReadState --> Exists{File exists?}\n    Exists -->|No| Create[\"Create with count=1\"]\n    Exists -->|Yes| Increment[\"Increment counter\"]\n    Create --> CheckLimit\n    Increment --> CheckLimit\n    CheckLimit{count > max?}\n    CheckLimit -->|No| Continue[\"Continue cycle\"]\n    CheckLimit -->|Yes| Halt[\"WAITING_FOR_HUMAN_DECISION<br/>Explicit options provided\"]\n    Continue --> WriteState[\"Write updated _iteration_state.json\"]\n```\n\n## Contracts and Data Models\n\n### Frontmatter FieldRule schema\n\n```go\ntype FieldRule struct {\n    Name     string   // field name in frontmatter\n    Required bool     // whether field must be present\n    Type     string   // \"string\", \"string_array\", \"enum\"\n    Enum     []string // allowed values (for enum type)\n}\n```\n\nRequired fields for `commands/spw/*.md`:\n- `name` (string, required)\n- `description` (string, required)\n- `argument-hint` (string, required)\n- `allowed-tools` (string_array, required)\n- `model` (enum: `[\"haiku\", \"sonnet\", \"opus\"]`, required)\n\n### Validation output JSON\n\n```json\n{\n  \"ok\": true,\n  \"summary\": \"13 files checked, 2 violations found\",\n  \"violations\": [\n    {\n      \"file\": \"commands/spw/exec.md\",\n      \"field\": \"allowed-tools\",\n      \"rule\": \"required\",\n      \"message\": \"missing required field 'allowed-tools'\"\n    }\n  ],\n  \"stats\": {\n    \"files_checked\": 13,\n    \"files_passed\": 11,\n    \"files_failed\": 2,\n    \"total_violations\": 2\n  }\n}\n```\n\n### Enhanced status.json contract\n\n```json\n{\n  \"status\": \"pass\",\n  \"summary\": \"Implementation complete with all tests passing\",\n  \"skills_used\": [\"conventional-commits\"],\n  \"skills_missing\": [],\n  \"model_override_reason\": null\n}\n```\n\nField types:\n- `status`: enum `\"pass\"` | `\"blocked\"` (required)\n- `summary`: non-empty string (required)\n- `skills_used`: string array (extended, required in strict mode)\n- `skills_missing`: string array (extended, required in strict mode)\n- `model_override_reason`: string or null (extended, required in strict mode)\n\n### Audit-extended status.json\n\n```json\n{\n  \"status\": \"blocked\",\n  \"summary\": \"Potential logic error in wave resume\",\n  \"confidence\": 0.65,\n  \"validated\": false,\n  \"skills_used\": [],\n  \"skills_missing\": [],\n  \"model_override_reason\": null\n}\n```\n\nAdditional fields for audit subagents:\n- `confidence`: float 0.0-1.0 (required for audit findings)\n- `validated`: boolean (required for audit findings)\n\n### AuditConfig\n\n```toml\n[audit]\naudit_min_confidence = 0.8\n```\n\n```go\ntype AuditConfig struct {\n    AuditMinConfidence float64 `toml:\"audit_min_confidence\"`\n}\n```\n\n### Iteration state file\n\n```json\n{\n  \"revision_count\": 2,\n  \"replan_count\": 0,\n  \"last_updated\": \"2026-02-13T10:30:00Z\"\n}\n```\n\n### ExecutionConfig extensions\n\n```go\ntype ExecutionConfig struct {\n    // ... existing fields ...\n    MaxRevisionAttempts int `toml:\"max_revision_attempts\"`\n    MaxReplanAttempts   int `toml:\"max_replan_attempts\"`\n}\n```\n\nDefaults: `max_revision_attempts=3`, `max_replan_attempts=2`.\n\n## Error Strategy\n\n- **Expected errors:**\n  - Missing frontmatter fields: reported as violations with file path, field name, and rule. Exit code 1.\n  - Mirror divergence: reported as divergent pairs with source and mirror paths. Exit code 1.\n  - Invalid status.json: reported with field-level errors. `valid=false` in output.\n  - Iteration limit exceeded: `WAITING_FOR_HUMAN_DECISION` status with explicit next-step options.\n- **Unexpected errors:**\n  - File read failures: wrapped with `fmt.Errorf(\"reading %s: %w\", path, err)`. Exit code 2.\n  - YAML parse failures: included in violations list (not a hard error for the batch).\n  - Config load failures: fall back to defaults with warning.\n- **Observability:**\n  - All violations include: rule name, file path, field, human-readable reason.\n  - `--json` output parseable by CI pipelines.\n  - Downgraded audit findings logged in `_handoff.md` under `## Downgraded Findings`.\n  - Iteration state changes logged with timestamp.\n\n## Test Strategy\n\n### Unit\n\n- `cli/internal/validate/prompts_test.go`: Table-driven tests for each `FieldRule`. Valid frontmatter, each missing field, invalid enum values, malformed YAML, empty input, extra unknown fields.\n- `cli/internal/validate/status_test.go`: All 5 fields present, missing optional (default vs strict), wrong types, invalid status enum, null vs missing distinction.\n- `cli/internal/validate/audit_test.go`: Confidence boundary tests (exactly 0.8, 0.79, 0.81). Downgrade behavior. `validated=false` handling. Missing confidence field.\n- `cli/internal/validate/mirror_test.go`: Matching content, divergent content, missing files, extra files, symlink targets.\n- `cli/internal/validate/iteration_test.go`: Counter creation, increment, threshold trigger, state persistence, config override.\n\n### Integration\n\n- `cli/internal/validate/prompts_integration_test.go`: End-to-end `spw validate prompts` on the actual `commands/spw/*.md` directory. Verifies no regressions.\n- Golden file tests for `--json` output format stability.\n- Config loading integration: verify `[audit]` section parses correctly alongside existing sections.\n\n### E2E/UAT\n\n- Smoke test: `spw validate prompts` completes in under 2 seconds on the standard repository (NFR).\n- Smoke test: `spw validate prompts --strict` detects intentional mirror divergence.\n- Smoke test: `spw validate prompts --json` produces valid JSON.\n\n## Risks and Mitigations\n\n| Risk | Mitigation |\n|---|---|\n| Old status.json files break with strict validation | Default mode tolerates missing optional fields. Strict is opt-in only. |\n| Wrong `allowed-tools` lists during frontmatter migration | Derive from workflow analysis. Include cross-check validation against actual workflow content. |\n| Embedded asset path mapping errors | Define explicit mapping table in `mirror.go`. Test with actual embedded files. |\n| Inconsistent audit confidence calibration | Document calibration guidelines with examples (syntax error=1.0, logic issue=0.7, style=0.4). Conservative default (0.8). Log all downgraded findings. |\n| Iteration limits too aggressive for complex specs | Configurable defaults. `WAITING_FOR_HUMAN_DECISION` provides explicit escape hatch. |\n| yaml.v3 dependency conflicts | No transitive dependencies. Pin version in `go.mod`. |\n| `validate` package becomes a kitchen sink | Strict boundary: only static validation logic. No runtime dispatch, no hooks, no config mutations. |\n\n## New Package Structure\n\n```\ncli/internal/\n  validate/\n    prompts.go           # Frontmatter validation logic\n    prompts_test.go      # Tests for frontmatter validation\n    mirror.go            # Mirror/embedded asset validation (--strict)\n    mirror_test.go       # Tests for mirror validation\n    status.go            # Enhanced status.json validation\n    status_test.go       # Tests for status validation\n    audit.go             # Audit confidence gate logic\n    audit_test.go        # Tests for audit gate\n    iteration.go         # Revision/replan counter logic\n    iteration_test.go    # Tests for iteration limits\n    schema.go            # Shared FieldRule types and helpers\n  cli/\n    validate_cmd.go      # Cobra command: spw validate prompts [--json] [--strict]\n  config/\n    config.go            # Extended: AuditConfig struct, ExecutionConfig fields\n```\n\n## Config Additions Summary\n\n```toml\n# New section\n[audit]\naudit_min_confidence = 0.8\n\n# New fields in existing [execution] section\n[execution]\nmax_revision_attempts = 3\nmax_replan_attempts = 2\n```\n",
  "fileStats": {
    "size": 17108,
    "lines": 375,
    "lastModified": "2026-02-13T19:58:14.296Z"
  },
  "comments": []
}